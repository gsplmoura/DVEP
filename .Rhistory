data_d1_exclusive <- data_d1_exclusive |>
mutate(drugs_w_loss = if_else(
record_id %in% drugs_w_loss, 1, 0)
)
rm(drugs_w_loss)
### 9.3.5 DRUGS THAT MIGHT INDUCE WEIGHT GAIN
#### Extract record IDs
drugs_w_gain <- I22_drugs_R |>
filter(str_detect(drugs_sql,
"C61879|C62005|C61917_2|C29416|C29536_2"
)
) |>
pull(record_id)
#### Assign drugs_w_loss based on drugs
data_d1_exclusive <- data_d1_exclusive |>
mutate(drugs_w_gain = if_else(
record_id %in% drugs_w_gain, 1, 0)
)
rm(drugs_w_gain)
data_d1_exclusive <- label_choices(data_d1_exclusive, codebook_dvep)
data_d1_exclusive <- convert_col_type(data_d1_exclusive, codebook_dvep)
data_d1_exclusive <- data_d1_exclusive |>
mutate(
hypertension = as.factor(hypertension),
dyslipidemia = as.factor(dyslipidemia),
insulin = as.factor(insulin),
drugs_w_loss = as.factor(drugs_w_loss),
drugs_w_gain = as.factor(drugs_w_gain)
)
data_d1_exclusive <- label_variables(data_d1_exclusive, codebook_dvep)
I27_labs_R <- filter_data(c("V1","V2","V3"),1,"labs") |>
mutate(
visit = case_when(
event_name == "1visit_arm_1"    ~ 1,
event_name == "2visit_arm_1"    ~ 2,
event_name == "3visit_arm_1"    ~ 3
),
.after = record_id
)|>
select(-event_name, -repeat_instrument, -repeat_instance, -labs_checked_results_yn)
compliance_V2 <- data |>
select(
record_id, event_name,
filter_variables("V2",1,"compliance")
) |>
filter(event_name == "2visit_arm_1" & cp_compliance_complete == 2) |>
left_join(data |>
filter(event_name == "eleg_arm_1" & !is.na(intervention_start_date)) |>
select(record_id,intervention_start_date, conclusion_date),
by = join_by(record_id)
) |>
left_join(data |>
filter(event_name == "2visit_arm_1" & !is.na(evaluation_date)) |>
select(record_id,evaluation_date),
by = join_by(record_id)
) |>
rename(evaluation_date_2 = evaluation_date)
compliance_V3 <- data |>
select(
record_id, event_name,
filter_variables("V3",,"compliance")
) |>
filter(event_name == "3visit_arm_1" & cp_compliance_complete == 2) |>
left_join(data |>
filter(event_name == "eleg_arm_1" & !is.na(intervention_start_date)) |>
select(record_id,intervention_start_date, conclusion_date),
by = join_by(record_id)
) |>
left_join(data |>
filter(event_name == "2visit_arm_1" & !is.na(evaluation_date)) |>
select(record_id,evaluation_date),
by = join_by(record_id)
) |>
rename(evaluation_date_2 = evaluation_date)
I29_compliance <- bind_rows(
compliance_V2,compliance_V3
) |>
mutate(
record_id = as.integer(record_id)
) |>
mutate(
visit = case_when(
event_name == "2visit_arm_1"    ~ 2,
event_name == "3visit_arm_1"    ~ 3
),
.after = record_id
) |>
arrange(record_id,visit) |>
select(record_id, visit, intervention_start_date, evaluation_date_2, conclusion_date, cp_taking_as_directed_yn, cp_schedule, cp_schedule_other, cp_missed_dose_yn, cp_missed_dose_count, cp_discontinued_yn, cp_discontinued_n_days, cp_discontinued_reason_other, cp_ran_out_of_drug_yn, cp_ran_out_reason, cp_perceived_improvement_yn, cp_perceived_improvement, cp_medication_confidence_scale, cp_self_reported_compliance_rate)  |>
convert_col_type()
rm(compliance_V2)
rm(compliance_V3)
I29_compliance <- label_variables(I29_compliance, codebook_dvep)
I29_compliance <- label_choices(I29_compliance, codebook_dvep)
## 9.9 Adverse events
I30_events_R <- filter_data(,1,"events") |>
filter(
cp_adverse_event_this_cycle_yn == 1
) |>
mutate(
visit = case_when(
event_name == "1visit_arm_1"    ~ 1,
event_name == "2visit_arm_1"    ~ 2,
event_name == "3visit_arm_1"    ~ 3
),
.after = record_id
)|>
select(-event_name, -repeat_instrument, -cp_additional_adverse_events_yn,  -cp_adverse_event_this_cycle_yn)
I30_events_R <- label_variables(I30_events_R, codebook_dvep)
I30_events_R <- label_choices(I30_events_R, codebook_dvep)
### Non-repeating data common to V1 and V3 (`d1d3`)
# calculate mean of handgrip strenght
# select relevant variables
d1d3 <- filter_data(c("V1","V3"),0) |>
mutate(
handgrip = if_else(
is.na(handgrip_right_mean) & is.na(handgrip_left_mean),
NA_real_,  # Leave blank (NA) if both are missing
if_else(
!is.na(handgrip_right_mean) & is.na(handgrip_left_mean),
handgrip_right_mean,  # Use the right hand value if left is missing
if_else(
is.na(handgrip_right_mean) & !is.na(handgrip_left_mean),
handgrip_left_mean,  # Use the left hand value if right is missing
rowMeans(cbind(handgrip_right_mean, handgrip_left_mean), na.rm = TRUE)  # Calculate mean if both are present
)
)
)
) |>
mutate(
visit = case_when(
event_name == "1visit_arm_1"    ~ 1,
event_name == "3visit_arm_1"    ~ 3
)
) |>
select(
record_id, visit,
whoqol_score_overall, # 4. whoqol
dass_score_depression:ecap_score, # 5. dass, 6. ecap
height, weight, abdomen, arm, bmi, # 7. measures
mean_bp_mean, # 9. bp
time_fasted_food, time_fasted_liquid, resistance, reactance, phase_angle, # 10. bia
handgrip, # 11. handgrip
# 12. eliminations
evs_score, # 14. evs
alcohol_dose, alcohol_significant, # 15. alcohol
smoke_history, pack_years,  # 16. tobacco
carbs_kcal, protein_kcal, fat_kcal, # 18. intake
drugs_dose_change_yn, drugs_dose_change_notes, # 31. medical
intervention_prevention_reason_yn, # 31. medical
specify_intervention_prevention_reasons, # 31. medical
intervention_delivered_yn, # 31. medical
explain_intervention_not_delivered # 31. medical
)
## 9.5 Non-repeating data from the second visit (`d2`)
d2 <- filter_data("V2",0) |>
mutate(
visit = case_when(
event_name == "2visit_arm_1"    ~ 2
)
) |>
select(
record_id, visit,
height, weight, abdomen, arm, bmi, # 7. measures
mean_bp_mean, # 9. bp
# 12. eliminations
evs_score, # 14. evs
drugs_dose_change_yn, drugs_dose_change_notes, # 31. medical
intervention_prevention_reason_yn, # 31. medical
specify_intervention_prevention_reasons, # 31. medical
intervention_delivered_yn, # 31. medical
explain_intervention_not_delivered # 31. medical
)
## 9.6 Bind rows for non-repeating variables from D1/D2/D3
data_filtered <- bind_rows(
d1d3,d2
) |>
mutate(
record_id = as.integer(record_id),
visit = as.integer(visit)
) |>
arrange(
record_id, visit
) |>
convert_col_type()
rm(d1d3)
rm(d2)
## 9.7. Left_join BIA data to `data_filtered`
data_filtered <- data_filtered |>
left_join(
data_bia |>
select(
record_id, visit,
phaseangle, raverage, xcaverage,
weight, height, waist, pal, bmi,
fmi, ffmi, vat,
w_tbw, w_ecw
),
by = join_by(record_id, visit)
)
data_filtered <- data_filtered |>
left_join(
I29_compliance,
by = join_by(record_id, visit)
)
data_filtered <- data_d1_exclusive |>
right_join(
data_filtered,
by = join_by(record_id)
) |>
relocate(
visit,
.after = record_id
)
data_filtered <- data_filtered |>
left_join(I27_labs_R,
by = join_by(record_id, visit)
)
data_filtered <- label_variables(data_filtered, codebook_dvep)
data_filtered <- label_variables(data_filtered, codebook_bia)
data_filtered <- data_filtered |>
mutate(
visit = as.integer(visit)
)
form_names <- unique(codebook_dvep$form_name_en)
form_names <- form_names[-2]
# Dynamically create the instruments list
instruments <- setNames(
lapply(form_names, function(form_name) {
filter_codebook(form_name, 0)$variable
}),
paste0("I", sprintf("%02d", seq_along(form_names)), "_", form_names)
)
# Estas variáveis não devem ser consideradas na verificação de dados faltantes (NA) porque sempre contêm informações.
always_present_vars <- c("record_id", "event_name", "repeat_instrument", "repeat_instance")
# Criar uma lista de tibbles separadas para cada instrumento, excluindo linhas que contenham apenas NAs
data_instruments <- lapply(names(instruments), function(instr_name) {
# `instr_name` é o nome atual do instrumento sendo processado, por exemplo, "elegibility".
# Seleciona a lista de variáveis associadas ao instrumento atual
selected_vars <- instruments[[instr_name]]
# Remove as variáveis da lista que estão em `always_present_vars` (que sempre possuem valores).
# `setdiff()` retorna apenas as variáveis exclusivas (aquelas que não estão em `always_present_vars`).
vars_to_check <- setdiff(selected_vars, always_present_vars)
# Filtrar os dados para o instrumento atual
filtered_tibble <- data  |>
# Seleciona as colunas correspondentes às variáveis do instrumento atual
select(all_of(selected_vars))  |>
# Filtra as linhas onde pelo menos uma das variáveis relevantes (não constantes) não é NA
filter(
rowSums(
!is.na(
select(cur_data(), all_of(vars_to_check)) # Seleciona apenas as colunas relevantes para a verificação de NA
)
) > 0 # `rowSums()` conta quantas colunas não são NA por linha. Mantemos linhas onde este total é maior que 0.
)
# Retorna a tibble filtrada com as variáveis e linhas relevantes para o instrumento atual
return(filtered_tibble)
})
# Nomeia os elementos da lista `data_instruments` com os nomes correspondentes dos instrumentos.
# Por exemplo, o primeiro elemento da lista será nomeado "redcap", o segundo "elegibility", e assim por diante.
names(data_instruments) <- names(instruments)
rm(always_present_vars)
rm(form_names)
rm(instruments)
# Opcional: Salvar cada tibble no ambiente global como um objeto independente.
# `list2env()` converte cada elemento da lista `data_instruments` em um objeto no ambiente global,
# com o nome correspondente ao instrumento.
#list2env(data_instruments, .GlobalEnv)
output_dir <- '/Users/gustavosplmoura/Library/Mobile Documents/com~apple~CloudDocs/Medicina/Biblioteca/Research/Data Science/Data Science/PROJECTS/DVEP/Generated data'
# Iterate over `data_instruments`
for (instr_name in names(data_instruments)) {
# Create the file path for the current instrument
file_path <- file.path(output_dir, paste0(instr_name, ".csv"))
# Write the tibble to a CSV file
write_csv(data_instruments[[instr_name]], file_path)
# Print a message confirming the export
message("Exported: ", file_path)
}
# Additional tibbles
write_csv(data_bia, file.path(output_dir, "data_bia.csv"))
write_csv(data_d1_exclusive, file.path(output_dir, "data_d1_exclusive.csv"))
write_csv(data_filtered, file.path(output_dir, "data_filtered.csv"))
rm(output_dir)
rm(file_path)
rm(instr_name)
summarize_numerical <- function(data, group_col = NULL, use_labels = TRUE) {
# Extract variable labels, falling back to variable names if labels are missing
variable_labels <- sapply(names(data), function(var) {
label <- attr(data[[var]], "label")
if (is.null(label) || !use_labels) var else label
}, simplify = TRUE)
# Identify numeric columns
numeric_cols <- data %>% select(where(is.numeric)) %>% names()
if (!is.null(group_col)) {
# Grouped summary
summary <- data %>%
group_by(across(all_of(group_col))) %>%
summarise(across(
all_of(numeric_cols),
~ paste0(
round(mean(.x, na.rm = TRUE), 1),
" (",
round(mean(.x, na.rm = TRUE) - 1.96 * sd(.x, na.rm = TRUE) / sqrt(sum(!is.na(.x))), 1),
"–",
round(mean(.x, na.rm = TRUE) + 1.96 * sd(.x, na.rm = TRUE) / sqrt(sum(!is.na(.x))), 1),
")"
),
.names = "{.col}"
)) %>%
pivot_longer(-all_of(group_col), names_to = "Variable", values_to = "Value") %>%
mutate(Variable = variable_labels[Variable]) # Replace variable names with labels/names
} else {
# Ungrouped summary
summary <- data %>%
summarise(across(
all_of(numeric_cols),
~ paste0(
round(mean(.x, na.rm = TRUE), 1),
" (",
round(mean(.x, na.rm = TRUE) - 1.96 * sd(.x, na.rm = TRUE) / sqrt(sum(!is.na(.x))), 1),
"–",
round(mean(.x, na.rm = TRUE) + 1.96 * sd(.x, na.rm = TRUE) / sqrt(sum(!is.na(.x))), 1),
")"
),
.names = "{.col}"
)) %>%
pivot_longer(everything(), names_to = "Variable", values_to = "Value") %>%
mutate(Variable = variable_labels[Variable]) # Replace variable names with labels/names
}
return(summary)
}
summarize_categorical <- function(data, group_col = NULL, use_labels = TRUE) {
# Extract variable labels, falling back to variable names if labels are missing
variable_labels <- sapply(names(data), function(var) {
label <- attr(data[[var]], "label")
if (is.null(label) || !use_labels) var else label
}, simplify = TRUE)
# Identify categorical columns
categorical_cols <- data %>% select(where(~ is.character(.x) || is.factor(.x))) %>% names()
if (!is.null(group_col)) {
# For grouped data
summary <- lapply(categorical_cols, function(col) {
data %>%
group_by(across(all_of(group_col)), .drop = FALSE) %>%
count(!!sym(col), .drop = FALSE, name = "Freq") %>%
mutate(
Percent = round(100 * Freq / sum(Freq), 1),
Variable = variable_labels[col] # Use labels or names
) %>%
rename(Level = !!sym(col)) %>%
ungroup()
}) %>%
bind_rows()
} else {
# For ungrouped data
summary <- lapply(categorical_cols, function(col) {
data %>%
count(!!sym(col), .drop = FALSE, name = "Freq") %>%
mutate(
Percent = round(100 * Freq / sum(Freq), 1),
Variable = variable_labels[col] # Use labels or names
) %>%
rename(Level = !!sym(col))
}) %>%
bind_rows()
}
# Arrange columns for consistency
summary <- summary %>%
select(Variable, Level, Freq, Percent, everything())
return(summary)
}
compare_groups <- function(data, group_col = "allocation_group", use_labels = TRUE) {
# Extract variable labels, default to variable names if labels are missing
# If use_labels = TRUE, fetch the 'label' attribute for each variable.
# If no label exists or use_labels = FALSE, default to the variable name.
variable_labels <- sapply(names(data), function(var) {
label <- attr(data[[var]], "label") # Check for the 'label' attribute
if (is.null(label) || !use_labels) var else label # Use variable name if label is missing
}, simplify = TRUE)
# Prepare results storage
# Create an empty data.frame to store test results with predefined columns
results <- data.frame(
Variable = character(), # The variable being tested
Test = character(),     # The type of test (t-test or chi-squared/Fisher's)
Statistic = numeric(),  # The test statistic value
P_value = numeric(),    # The p-value from the test
stringsAsFactors = FALSE # Ensure strings are not converted to factors
)
# Loop through all columns in the data, excluding the grouping column
for (var in setdiff(names(data), group_col)) {
if (is.numeric(data[[var]])) {
# Run t-test for numeric variables
# Compares the means of the variable between the groups in group_col
test_result <- t.test(data[[var]] ~ data[[group_col]])
# Append the t-test results to the results data.frame
results <- rbind(results, data.frame(
Variable = variable_labels[var], # Use label or name
Test = "t-test",                 # Specify the test type
Statistic = round(test_result$statistic, 2), # Round the t-statistic
P_value = round(test_result$p.value, 4)     # Round the p-value
))
} else if (is.factor(data[[var]]) || is.character(data[[var]])) {
# Run chi-squared test for categorical variables
# Create a contingency table for the variable and the group_col
contingency_table <- table(data[[var]], data[[group_col]])
# Check expected counts to decide between chi-squared and Fisher's test
if (any(chisq.test(contingency_table)$expected < 5)) {
# Use Fisher's exact test when expected counts are too small
test_result <- fisher.test(contingency_table)
# Append the Fisher's exact test results to the results data.frame
results <- rbind(results, data.frame(
Variable = variable_labels[var], # Use label or name
Test = "Fisher's exact test",    # Specify the test type
Statistic = NA,                  # No statistic for Fisher's test
P_value = round(test_result$p.value, 4) # Round the p-value
))
} else {
# Use chi-squared test when expected counts are sufficient
test_result <- tryCatch(
chisq.test(contingency_table), # Perform the chi-squared test
error = function(e) list(statistic = NA, p.value = NA) # Handle potential errors
)
# Append the chi-squared test results to the results data.frame
results <- rbind(results, data.frame(
Variable = variable_labels[var], # Use label or name
Test = "Chi-squared test",       # Specify the test type
Statistic = round(test_result$statistic, 2), # Round the chi-squared statistic
P_value = round(test_result$p.value, 4)     # Round the p-value
))
}
}
}
# Return results as a gt table
# Convert the results data.frame into a gt table for better visualization
gt_table <- results %>%
gt() %>%
tab_header(
title = "Hypothesis Test Results",       # Main title for the table
subtitle = paste("Comparison of", group_col) # Subtitle indicating the grouping variable
) %>%
cols_label(
Variable = "Variable",          # Rename the Variable column
Test = "Test Type",             # Rename the Test column
Statistic = "Test Statistic",   # Rename the Statistic column
P_value = "P-value"             # Rename the P_value column
)
return(gt_table) # Return the formatted gt table
}
# Run the function and display results
test_results <- compare_groups(data_d1_exclusive)
# Print the results
print(test_results)
# Run the function and display results
test_results <- compare_groups(data_d1_exclusive)
rm(test_results)
baseline_num <- summarize_numerical(data_d1_exclusive)
baseline_num %>%
gt() %>%
tab_header(
title = "Numerical Variable Summary",
subtitle = "Overall Summary"
)
baseline_cat <- summarize_categorical(data_d1_exclusive)
baseline_cat %>%
gt() %>%
tab_header(
title = "Categorical Variable Summary",
subtitle = "Overall Summary"
)
baseline_num_group <- summarize_numerical(data_d1_exclusive, "allocation_group")
baseline_num_group %>%
gt() %>%
tab_header(
title = "Numerical Variable Summary",
subtitle = "Overall Summary"
)
baseline_cat_group <- summarize_categorical(data_d1_exclusive, "allocation_group")
baseline_cat_group %>%
gt() %>%
tab_header(
title = "Categorical Variable Summary",
subtitle = "Overall Summary"
)
# Run the function and display results
group_comparison <- compare_groups(data_d1_exclusive)
# Print the table
print(group_comparison)
baseline_num_group <- summarize_numerical(data_d1_exclusive, "allocation_group")
baseline_num_group %>%
gt() %>%
tab_header(
title = "Numerical Variable Summary",
subtitle = "Overall Summary"
)
baseline_cat_group <- summarize_categorical(data_d1_exclusive, "allocation_group")
baseline_cat_group %>%
gt() %>%
tab_header(
title = "Categorical Variable Summary",
subtitle = "Overall Summary"
)
# Run the function and display results
group_comparison <- compare_groups(data_d1_exclusive)
# Print the table
print(group_comparison)
library(tidyverse)
as_factor(x)
mtcars
|>
? |>
? |>
install.packages("tidyverse")
